type VaultDeposit @entity {
  id: String!
  vault: Vault!
  user: Bytes!
  amount: BigInt!
  timestamp: BigInt!        # Deprecated - use requestedAt or processedAt
  
  # ScrubVault specific fields
  status: String            # "pending" | "processed" for ScrubVault
  fee: BigInt              # Deposit fee for ScrubVault
  sharesMinted: BigInt     # Shares received for ScrubVault
  requestedAt: BigInt      # When deposit was requested
  processedAt: BigInt      # When deposit was processed (null if pending)
}

type VaultWithdraw @entity {
  id: String!
  vault: Vault!
  user: Bytes!
  amount: BigInt!
  timestamp: BigInt!       # Deprecated - use requestedAt or processedAt
  
  # ScrubVault specific fields
  shares: BigInt           # Shares burned for ScrubVault
  status: String           # "pending" | "processed" for ScrubVault
  fee: BigInt              # Withdrawal fee for ScrubVault
  requestedAt: BigInt      # When withdrawal was requested
  canBeApprovedAt: BigInt  # When withdrawal can be processed
  processedAt: BigInt      # When withdrawal was processed (null if pending)
}

type VaultReward @entity {
  id: String!
  vault: Vault!
  apr: BigInt!
  reward: BigInt!
  timestamp: BigInt!
}

type VaultInfo @entity {
  id: String!
  vault: Vault!
  timestamp: BigInt!
  tvl: BigInt!
  apr: BigInt!
  totalSupplied: BigInt!
  totalBorrowed: BigInt!
  totalBorrowable: BigInt!
  lastCompoundTimestamp: BigInt!
}

type VaultUser @entity {
  id: String! # Format: "{vaultAddress}-{userAddress}"
  vault: Vault!
  user: Bytes!
  shareBalance: BigInt!
  pendingWithdrawalShares: BigInt! # Shares locked in pending withdrawals
  pendingDepositCount: BigInt!
  pendingWithdrawalCount: BigInt!
  totalDeposited: BigInt!
  totalWithdrawn: BigInt!
  lastInteractionTimestamp: BigInt!
}

type Vault @entity {
  id: String!
  infos: [VaultInfo!]! @derivedFrom(field: "vault")
  underlying: Bytes!
  decimals: BigInt!
  tokenName: String!
  deposits: [VaultDeposit!]! @derivedFrom(field: "vault")
  withdrawals: [VaultWithdraw!]! @derivedFrom(field: "vault")
  rewards: [VaultReward!]! @derivedFrom(field: "vault")
  users: [VaultUser!]! @derivedFrom(field: "vault")
  
  # Discriminator: "hover" for legacy vaults, "scrub" for new deposit vaults
  vaultType: String
  
  # ScrubVault specific fields (optional for backward compatibility)
  shareToken: Bytes
  strategy: Bytes
  treasury: Bytes
  totalShares: BigInt
  shareValue: BigInt
  totalUsers: BigInt
  totalPendingWithdrawalShares: BigInt
  paused: Boolean
  
  # Current vault state (updated on every event)
  tvl: BigInt                      # Total Value Locked - fetched from contract
  apr: BigInt                      # Annual Percentage Rate (if tracked)
  
  # Compound tracking
  lastCompoundTimestamp: BigInt
  
  # Configurable fees and limits (ScrubVault)
  depositFee: BigInt
  withdrawalFee: BigInt
  minDeposit: BigInt
  minWithdrawalShares: BigInt
}

type Lock @entity {
  id: String!
  nftID: BigInt!
  user: Bytes!
  amount: BigInt!
  deposited: BigInt!
  tx: Bytes!
  timestamp: BigInt!
  merged: Boolean!
}

type Vote @entity {
  id: String!
  user: Bytes!
  nftID: BigInt!
  amount: BigInt!
  pool: Bytes!
  timestamp: BigInt!
  lock: Lock
  weight: BigDecimal!
}

type Bomb @entity {
  id: String!
  run: BigInt
  resets: [Reset!]! @derivedFrom(field: "bomb")
  currentJackpot: BigInt!
  currentWinner: Bytes!
}

type Reset @entity {
  id: String!
  user: Bytes!
  bomb: Bomb!
  timestamp: BigInt!
  currentJackpot: BigInt!
}

type BasicInfo @entity {
  id: String!
  competitionId: BigInt!
  contractAddress: Bytes!
  openStatus: Boolean!
  host: BigInt!
  guest: BigInt!
  result: BigInt!
  currentBetId: BigInt!
  totalAmountMatchedEffective: BigInt!
  competitionPendingAmount: BigInt!
  outright: Boolean!
  live: Boolean!
  hidden: Boolean!
  fee: BigInt!
  competitionsAddress: Bytes!
  startDate: BigInt!
}

type AdditionalInfo @entity {
  id: String!
  additionalHome: String!
  additionalAway: String!
  betType: String!
  preview: Boolean!
}

type CompetitionInfo @entity {
  id: String!
  basicInfo: BasicInfo!
  bets: [BetInfo!]! @derivedFrom(field: "competition")
  betCount: Int!
  additionalInfo: AdditionalInfo!
  users: [Bytes!]!
}

type BetInfo @entity {
  id: String!
  betId: BigInt!
  competition: CompetitionInfo!
  backUser: Bytes!
  team: BigInt!
  pendingAmount: BigInt!
  totalMatched: BigInt!
  odd: BigInt!
  effectiveOdd: BigInt!
  collateral: BigInt!
  matchedBetsList: [MatchedBet!]! @derivedFrom(field: "bet")
  settled: Boolean!
  users: [Bytes!]!
}

type MatchedBet @entity {
  id: String!
  bet: BetInfo!
  layUser: Bytes!
  amount: BigInt!
}

# ==================== ScrubPoint ====================

type ScrubPointMint @entity {
  id: ID! # txHash-logIndex
  recipient: Bytes!
  amount: BigInt!
  totalSupply: BigInt!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: Bytes!
}

type ScrubPointTransfer @entity {
  id: ID! # txHash-logIndex
  from: Bytes!
  to: Bytes!
  amount: BigInt!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: Bytes!
}

type ScrubPointHolder @entity {
  id: ID! # userAddress
  address: Bytes!
  balance: BigInt!
  totalReceived: BigInt!
  totalSent: BigInt!
  firstSeenAt: BigInt!
  lastActivityAt: BigInt!
}

type ScrubPointStats @entity {
  id: ID! # "singleton"
  totalSupply: BigInt!
  totalHolders: Int!
  totalMints: Int!
  totalTransfers: Int!
  firstMintAt: BigInt!
  lastActivityAt: BigInt!
}

# ==================== ScrubVault Cave ====================

type CaveDeposit @entity {
  id: ID! # txHash-logIndex
  user: CaveUser!
  pointAmount: BigInt!
  sharesReceived: BigInt!
  totalSharesAfter: BigInt!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: Bytes!
}

type CaveWithdrawal @entity {
  id: ID! # txHash-logIndex
  user: CaveUser!
  sharesBurned: BigInt!
  pointsReceived: BigInt!
  totalSharesAfter: BigInt!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: Bytes!
}

type CavePointPurchase @entity {
  id: ID! # txHash-logIndex
  buyer: CaveUser!
  pointAmount: BigInt!
  usdtPaid: BigInt!
  pricePerToken: BigInt!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: Bytes!
}

type CaveUsdtClaim @entity {
  id: ID! # txHash-logIndex
  user: CaveUser!
  amount: BigInt!
  totalClaimedByUser: BigInt!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: Bytes!
}

type CavePriceUpdate @entity {
  id: ID! # txHash-logIndex
  oldPrice: BigInt!
  newPrice: BigInt!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: Bytes!
}

type CaveInventoryDeposit @entity {
  id: ID! # txHash-logIndex
  owner: Bytes!
  amount: BigInt!
  totalInventoryAfter: BigInt!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: Bytes!
}

type CaveUser @entity {
  id: ID! # userAddress
  address: Bytes!
  totalDeposits: BigInt!
  totalDepositCount: Int!
  totalWithdrawals: BigInt!
  totalWithdrawalCount: Int!
  currentShares: BigInt!
  totalPointsPurchased: BigInt!
  totalUsdtSpent: BigInt!
  purchaseCount: Int!
  totalUsdtClaimed: BigInt!
  claimCount: Int!
  firstActivityAt: BigInt!
  lastActivityAt: BigInt!
  deposits: [CaveDeposit!]! @derivedFrom(field: "user")
  withdrawals: [CaveWithdrawal!]! @derivedFrom(field: "user")
  purchases: [CavePointPurchase!]! @derivedFrom(field: "buyer")
  claims: [CaveUsdtClaim!]! @derivedFrom(field: "user")
}

type CaveStats @entity {
  id: ID! # "singleton"
  totalShares: BigInt!
  totalDeposits: BigInt!
  totalWithdrawals: BigInt!
  totalInventory: BigInt!
  totalPointsSold: BigInt!
  totalUsdtCollected: BigInt!
  uniqueDepositors: Int!
  uniqueBuyers: Int!
  uniqueClaimers: Int!
  totalDepositCount: Int!
  totalWithdrawalCount: Int!
  totalPurchaseCount: Int!
  totalClaimCount: Int!
  currentPrice: BigInt!
  priceUpdateCount: Int!
  firstActivityAt: BigInt!
  lastActivityAt: BigInt!
}
